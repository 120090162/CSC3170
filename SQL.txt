SQL对关键字的大小写不敏感
SQL语句可以分开行写，以;为结束
注释：
单行-- 后面有空格。#后面可加可不加
多行/**/

DDL(Data Definition Language)数据定义语言
-- DDL
-- 查看所有数据库
show DATABASES;
-- 创建数据库
CREATE DATABASE mydb1;
CREATE DATABASE if not EXISTS mydb1;
-- 选择使用哪一个数据库
USE mydb1;
-- 删除数据库
DROP DATABASE mydb1;
DROP DATABASE if EXISTS mydb1;

CREATE DATABASE if not EXISTS mydb1;
USE mydb1;
--创建表
CREATE table if not EXISTS student(
-- sid TINYINT UNSIGNED;
-- DECIMAL(M,D) M表示有效位数,D表示小数点个数
sid int,
name VARCHAR(20),
gender varchar(10),
age int,
birth date,
address VARCHAR(20)
);

数据类型是指在创建表的时候为表中字段指定数据类型，只有数据符合类型要求才能储存，原则是够用就行，尽量选取值范围小的

USE mydb1;
-- 查看当前数据库所有的表
SHOW TABLES;
-- 查看指定表的创建语句
show CREATE table student;
-- 查看表结构
desc student;
-- 删除表
drop table student;

USE mydb1;
-- 修改表结构
-- 添加列
alter table student add dept VARCHAR(20);
-- 修改列名和类型
ALTER table student change dept department VARCHAR(30);
-- 删除列
ALTER table student drop department;
-- 修改表名
rename table student to stu;

DML(Data Manipulation Language)对表中数据记录进行更新
USE mydb1;
-- 数据的插入
-- 指定列赋值
insert into student(sid, name, gender, age, birth, address)
values(1001, '张三', '男', 18, '2001-12-23', '北京'),
(1002, '李四', '男', 18, '2002-12-23', '北京')
;
-- 一次性赋值所有列
INSERT into student VALUES(1003, '王五', '男', 18, '2003-12-23', '北京');
-- 数据修改
UPDATE student set address = '重庆',
									 name = 'joshua';
UPDATE student set address = 'hongkong' WHERE sid >= 1002;
-- 数据删除
DELETE FROM student where sid > 1002;
-- 清空数据
DELETE FROM student;
TRUNCATE table student;
TRUNCATE student;
-- TRUNCATE是将表直接删除然后再创建一个新表，DELETE是将内容删除

MySQL约束
MySQL主键约束是一个列或者多个列的组合，其值能唯一地标识表中的每一行，方便快速查找
每个每个表只能有一个主键
主键不能为空也不能重复
-- 一个主键
CREATE table if not EXISTS mydb1.emp(
		eid int PRIMARY key,
		name VARCHAR(20),
		deptID int,
		salary DOUBLE
);
CREATE table if not EXISTS mydb1.emp(
		eid int,
		name VARCHAR(20),
		deptID int,
		salary DOUBLE,
		CONSISTENT pk1 PRIMARY KEY(eid)  -- CONSISTENT pk1 可以省略
);
-- 联合主键
CREATE table if not EXISTS mydb1.emp(
		eid int,
		name VARCHAR(20),
		deptID int,
		salary DOUBLE,
		CONSISTENT pk PRIMARY KEY(eid, deptID)
);
-- 通过修改表结构来添加主键
CREATE table if not EXISTS mydb1.emp(
		eid int,
		name VARCHAR(20),
		deptID int,
		salary DOUBLE
);
alter table mydb1.emp add PRIMARY key(eid, deptID);
-- 删除主键
ALTER table mydb1.emp drop primary key;

自增长约束：实现主键自动赋值，每增加一条记录，主键以相同步长增长
CREATE TABLE mydb1.user1(
	id int PRIMARY key auto_increment,
	name VARCHAR(20)
);
use mydb1;
INSERT into user1 VALUES(NULL, '张三');
INSERT into user1(name) VALUES('李四');
默认情况下，自增长的初始值为1，且自增是1
一个表只能有一个字段使用自增长，且该字段必须具有唯一索引，且为整数，最大值受该字段的数据类型约束，达到上限则失效
-- 指定初始值
-- 创建时指定
CREATE TABLE mydb1.user1(
	id int PRIMARY key auto_increment,
	name VARCHAR(20)
)auto_increment = 100;
-- 创建后指定
ALTER TABLE mydb1.user1 auto_increment = 100;
-- delet数据之后从自增长从断点开始
-- TRUNCATE数据之后自增长从初始值开始

非空约束
空串不等于NULL
-- 创建时指定
USE mydb1;
CREATE TABLE USER2(
	ID INT,
	NAME VARCHAR(20) NOT NULL,
	ADDRESS VARCHAR(20) NOT NULL
);
-- 创建后指定
ALTER TABLE USER2 MODIFY NAME VARCHAR(20) NOT NULL;
-- 删除非空约束
ALTER TABLE USER2 MODIFY NAME VARCHAR(20);

唯一约束
值不能重复
NULL和任何值都不相同，NULL和NULL也不相同
-- 创建时指定
USE mydb1;
CREATE TABLE USER3(
	ID INT,
	NAME VARCHAR(20),
	ADDRESS VARCHAR(20) UNIQUE
);
-- 创建后指定
ALTER TABLE USER2 ADD CONSTRAINT UNIQUE_ADD UNIQUE(ADDRESS);
-- 删除
ALTER TABLE USER2 DROP INDEX UNIQUE_ADD;
-- 约束名默认是列名

默认约束
-- 创建时指定
USE mydb1;
CREATE TABLE USER4(
	ID INT,
	NAME VARCHAR(20),
	ADDRESS VARCHAR(20) DEFAULT 'HONGKONG'
);
-- 创建后指定
ALTER TABLE USER4 MODIFY ADDRESS VARCHAR(20) DEFAULT 'SHENZHEN';
-- 删除
ALTER TABLE USER4 MODIFY ADDRESS VARCHAR(20) DEFAULT NULL;

零填充约束
插入数据时，当字段的值的长度小于定义的长度时，会在该值的前面补上相应的0
默认为int(10)，默认会自动加unsigned符号
-- 创建时指定
USE mydb1;
CREATE TABLE USER5(
	ID INT ZEROFILL, -- int默认字段为11
	NAME VARCHAR(20)
);
INSERT INTO USER5 VALUES(123, 'JOSHUA');
-- 删除
ALTER TABLE USER5 MODIFY ID INT;

DQL基本查询
CREATE DATABASE IF NOT EXISTS mydb2;
USE MYDB2;
CREATE TABLE IF NOT EXISTS PRODUCT(
	PID INT PRIMARY KEY AUTO_INCREMENT,
	PNAME VARCHAR(20) NOT NULL,
	PRICE DOUBLE,
	CATEGORY_ID VARCHAR(20)
);
INSERT INTO PRODUCT VALUES(NULL, '海尔洗衣机', 5000, 'C001');
INSERT INTO PRODUCT VALUES(NULL, '美的冰箱', 3000, 'C001');
INSERT INTO PRODUCT VALUES(NULL, '格力空调', 5000, 'C001');
INSERT INTO PRODUCT VALUES(NULL, '九阳电饭煲', 5000, 'C001');

INSERT INTO PRODUCT VALUES(NULL, '啄木鸟衬衣', 300, 'C002');
INSERT INTO PRODUCT VALUES(NULL, '恒源祥西裤', 800, 'C002');
INSERT INTO PRODUCT VALUES(NULL, '花花公子夹克', 440, 'C002');
INSERT INTO PRODUCT VALUES(NULL, '劲霸休闲裤', 266, 'C002');
INSERT INTO PRODUCT VALUES(NULL, '海澜之家卫衣', 180, 'C002');
INSERT INTO PRODUCT VALUES(NULL, '杰克琼斯运动裤', 430, 'C002');

INSERT INTO PRODUCT VALUES(NULL, '兰蔻面霜', 300, 'C003');
INSERT INTO PRODUCT VALUES(NULL, '雅诗兰黛精华水', 200, 'C003');
INSERT INTO PRODUCT VALUES(NULL, '香奈儿香水', 350, 'C003');
INSERT INTO PRODUCT VALUES(NULL, 'SK-II神仙水', 350, 'C003');
INSERT INTO PRODUCT VALUES(NULL, '资生堂粉底液', 180, 'C003');

INSERT INTO PRODUCT VALUES(NULL, '老北京方便面', 56, 'C004');
INSERT INTO PRODUCT VALUES(NULL, '良品铺子海带丝', 17, 'C004');
INSERT INTO PRODUCT VALUES(NULL, '三只松鼠坚果', 88, NULL);

USE MYDB2;
-- 简单查询
-- 1.查询所有商品
SELECT PID, PNAME, PRICE, CATEGORY_ID FROM PRODUCT;
SELECT * FROM PRODUCT;
-- 2.查询商品名和价格
SELECT PNAME, PRICE FROM PRODUCT;
-- 3.别名查询，AS可以省略
-- 3.1表别名
SELECT * FROM PRODUCT AS P;
SELECT * FROM PRODUCT P;
-- 3.2列别名
SELECT PNAME AS 'ITEM', PRICE 'ITEM PRICE' FROM PRODUCT;
-- 4.去掉重复值，一般只对一列用
SELECT DISTINCT PRICE FROM PRODUCT;
SELECT DISTINCT * FROM PRODUCT;
-- 5.运算查询（查询结果是表达式）
SELECT PNAME, PRICE + 10 AS NEW_PRICE FROM PRODUCT; -- 不改变原表的值

USE MYDB2;
SELECT * FROM PRODUCT WHERE PNAME = '海尔洗衣机';

SELECT * FROM PRODUCT WHERE PRICE = 800;
SELECT * FROM PRODUCT WHERE PRICE != 800;
SELECT * FROM PRODUCT WHERE PRICE <> 800;
SELECT * FROM PRODUCT WHERE NOT (PRICE = 800);

SELECT * FROM PRODUCT WHERE PRICE >= 60;

SELECT * FROM PRODUCT WHERE PRICE BETWEEN 200 AND 1000;
SELECT * FROM PRODUCT WHERE PRICE >= 200 AND PRICE <= 1000;
SELECT * FROM PRODUCT WHERE PRICE >= 200 && PRICE <= 1000;

SELECT * FROM PRODUCT WHERE PRICE IN(200, 800);
SELECT * FROM PRODUCT WHERE PRICE = 200 OR PRICE = 800;
SELECT * FROM PRODUCT WHERE PRICE = 200 || PRICE = 800;

SELECT * FROM PRODUCT WHERE PNAME LIKE '%裤%'; -- %用来匹配任何字符
SELECT * FROM PRODUCT WHERE PNAME LIKE '海%';

SELECT * FROM PRODUCT WHERE PNAME LIKE '_蔻%'; -- _用来匹配单个字符

SELECT * FROM PRODUCT WHERE CATEGORY_ID IS NULL;
SELECT * FROM PRODUCT WHERE CATEGORY_ID IS NOT NULL;

SELECT LEAST(1,2,3) AS SMALL_NUMBER;
SELECT GREATEST(NULL,2,3);
-- 如果比较值有NULL则不比较直接输出为NULL

USE MYDB2;
-- 排序查询 默认升序
SELECT * FROM PRODUCT ORDER BY PRICE DESC;
-- 在价格降序的基础上以分类降序
SELECT * FROM PRODUCT ORDER BY PRICE DESC, CATEGORY_ID DESC;
-- 价格去重，降序
SELECT DISTINCT PRICE FROM PRODUCT ORDER BY PRICE DESC;

USE MYDB2;
-- 聚合函数 忽略NULL行的存在
SELECT COUNT(PID) FROM PRODUCT; -- 不会统计值为NULL的行
SELECT COUNT(*) FROM PRODUCT;

SELECT COUNT(PID) FROM PRODUCT WHERE PRICE > 200;

SELECT SUM(PRICE) FROM PRODUCT WHERE CATEGORY_ID = 'C001';

SELECT MAX(PRICE) MAX_P, MIN(PRICE) MIN_P, AVG(PRICE) AVG_P FROM PRODUCT;

USE MYDB2;
-- 分组查询
-- 将一张表切成几个临时表
SELECT CATEGORY_ID, COUNT(PID) FROM PRODUCT GROUP BY CATEGORY_ID;
SELECT CATEGORY_ID, COUNT(PID) FROM PRODUCT WHERE CATEGORY_ID IS NOT NULL GROUP BY CATEGORY_ID;
-- SELECT CATEGORY_ID, COUNT(PID) FROM PRODUCT GROUP BY CATEGORY_ID HAVING COUNT(PID) > 4 ORDER BY COUNT(PID) DESC;
SELECT
	CATEGORY_ID,
	COUNT( PID ) 
FROM
	PRODUCT 
GROUP BY
	CATEGORY_ID 
HAVING
	COUNT( PID ) > 4 
ORDER BY
	COUNT( PID ) DESC;
-- 执行顺序:FROM->GROUP BY->COUNT->HAVING

USE MYDB2;
-- 分页查询
SELECT * FROM PRODUCT LIMIT 5;
SELECT * FROM PRODUCT LIMIT 3, 5; -- 0表示第一个数据,(M-1)*N

USE MYDB2;
-- 将一个表的数据插入另一个表
CREATE TABLE TPRODUCT(
	PNAME VARCHAR(20),
	PRICE DOUBLE
);

INSERT INTO TPRODUCT(PNAME, PRICE) SELECT PNAME, PRICE FROM PRODUCT;
SELECT * FROM TPRODUCT;

CREATE TABLE CPRODUCT(
	CATEGORY_ID VARCHAR(20),
	PRODUCT_COUNT INT
);

INSERT INTO CPRODUCT SELECT
CATEGORY_ID,
COUNT(*) 
FROM
	PRODUCT 
WHERE
	CATEGORY_ID IS NOT NULL 
GROUP BY
	CATEGORY_ID;
SELECT * FROM CPRODUCT;

SQL书写顺序
SELECT->FROM->WHERE->GROUP BY->HAVING->ORDER BY->LIMIT

-- 练习
USE MYDB2;
CREATE TABLE STUDENT(
	ID INT,
	NAME VARCHAR(20),
	GENDER VARCHAR(20),
	CHINESE INT,
	ENGLISH INT,
	MATH INT
);

INSERT INTO student VALUES(1, '张明', '男', 89, 78, 90);
INSERT INTO student VALUES(2, '李进', '男', 67, 53, 95);
INSERT INTO student VALUES(3, '王五', '女', 87, 78, 77);
INSERT INTO student VALUES(4, '李一', '女', 88, 98, 92);
INSERT INTO student VALUES(5, '李财', '男', 82, 84, 67);
INSERT INTO student VALUES(6, '张宝', '男', 55, 85, 45);
INSERT INTO student VALUES(7, '黄蓉', '女', 75, 65, 30);
INSERT INTO student VALUES(7, '黄蓉', '女', 75, 65, 30);

SELECT * FROM student;
SELECT NAME, ENGLISH FROM student;
SELECT DISTINCT * FROM student;

SELECT NAME, CHINESE + ENGLISH + MATH AS TOTAL_SCORE FROM student;

SELECT NAME '姓名', CHINESE '语文成绩', ENGLISH '英语成绩', MATH '数学成绩' FROM student;

SELECT * FROM student WHERE CHINESE + ENGLISH + MATH > 200;

SELECT * FROM student WHERE ENGLISH BETWEEN 80 AND 90;

SELECT * FROM student WHERE NOT (ENGLISH BETWEEN 80 AND 90);
SELECT * FROM student WHERE ENGLISH NOT BETWEEN 80 AND 90;

SELECT * FROM student WHERE MATH IN(89, 90, 91);
SELECT NAME, ENGLISH FROM student WHERE NAME LIKE '李%';
SELECT * FROM student ORDER BY MATH DESC;

SELECT gender, COUNT(1) FROM student GROUP BY gender;

IFNULL(A,B)如果A为NULL,值为B;如果A不为NULL,值不变

正则表达式(regular expression)
USE mydb2;
-- ^ 在字符串开始处进行匹配
SELECT 'ABC' REGEXP '^A';
SELECT * FROM product WHERE PNAME REGEXP '^海';
-- $ 在字符串末尾开始匹配
SELECT 'ABC' REGEXP 'A$';
SELECT 'ABC' REGEXP 'C$';
SELECT * FROM product WHERE PNAME REGEXP '裤$';
-- . 匹配任意单个字符，除了'\N';
SELECT 'ABC' REGEXP 'A.';
SELECT 'ABC' REGEXP '.B';
-- [...] 匹配括号内的任意单个字符
SELECT 'ABC' REGEXP '[XYZ]';
SELECT 'ABC' REGEXP '[XAZ]';
-- [^...] ^此时表示取反
SELECT 'ABC' REGEXP '[^XYZ]';
-- A* 表示匹配0或多个A，包括空字符串。可以作为占位符使用，有没有指定字符串都可以匹配到数据
SELECT 'STAB' REGEXP '.TA*B';
SELECT '' REGEXP 'A*';
-- A+ 表示匹配1或多个A
SELECT 'STB' REGEXP '.TA+B';
-- A? 匹配0或1个A
SELECT 'STAB' REGEXP '.TA?B';
SELECT 'STB' REGEXP '.TA?B';
-- A1|A2 匹配A1或A2
SELECT 'A' REGEXP 'A|B';
SELECT 'B' REGEXP '^(A|B)';
-- A{M} 匹配M个A
SELECT 'AUUUUUC' REGEXP 'AU{5}C';
-- A{M,} 匹配至少M个A
SELECT 'AUUUUUC' REGEXP 'AU{4,}C';
-- A{M,N} 至少匹配M次,至多匹配N次,M小于等于N
SELECT 'AUUUUUC' REGEXP 'AU{3,5}C';
-- (ABC) 表示将ABC作为一个整体序列进行匹配，否则默认都是单个字符
SELECT 'XABABY' REGEXP 'X(AB)*Y';
SELECT 'XY' REGEXP 'X(AB)*Y';

多表操作
外键约束(FOREIGN KEY)，主键所在的表是主表，外键所在的表是从表
主键不能为空，但外键可以为空，即非空的外键值必须在主键值中
CREATE DATABASE MYDB3;
USE MYDB3;
CREATE TABLE DEPT(
	DEPTNO VARCHAR(20) PRIMARY KEY,
	NAME VARCHAR(20)
);

CREATE TABLE EMP(
	EID VARCHAR(20) PRIMARY KEY,
	ENAME VARCHAR(20),
	AGE INT,
	DEPT_ID VARCHAR(20),
	CONSTRAINT EMP_FK FOREIGN KEY(DEPT_ID) REFERENCES DEPT(DEPTNO)
);
-- ALTER TABLE EMP ADD CONSTRAINT EMP_FK FOREIGN KEY(DEPT_ID) REFERENCES DEPT(DEPTNO)

USE MYDB3;
-- 数据插入
-- 必须先给主表添加数据，从表数据的值必须依赖主表
INSERT INTO DEPT VALUES('1001', '研发部');
INSERT INTO DEPT VALUES('1002', '销售部');
INSERT INTO DEPT VALUES('1003', '财务部');
INSERT INTO DEPT VALUES('1004', '人事部');

INSERT INTO EMP VALUES('1', '乔峰', 20, '1001');
INSERT INTO EMP VALUES('2', '段誉', 21, '1001');
INSERT INTO EMP VALUES('3', '虚竹', 23, '1001');
-- 数据删除
-- 主表的数据被从表依赖时不能删除，从表数据可以随便删除
DELETE FROM DEPT WHERE DEPTNO = '1001'; -- FALSE
DELETE FROM DEPT WHERE DEPTNO = '1002';

USE MYDB3;
-- 删除外键约束
SHOW CREATE TABLE EMP;
ALTER TABLE EMP DROP FOREIGN KEY EMP_FK;

USE MYDB3;
-- 外键约束，多对多，需要创造一个中间表作为子表
CREATE TABLE student(
	SID INT PRIMARY KEY AUTO_INCREMENT,
	NAME VARCHAR(20),
	AGE INT,
	GENDER VARCHAR(20)
);

CREATE TABLE COURSE(
	CID INT PRIMARY KEY AUTO_INCREMENT,
	CIDNAME VARCHAR(20)
);

CREATE TABLE SCORE(
	SID INT,
	CID INT,
	SCORE DOUBLE
);

ALTER TABLE SCORE ADD FOREIGN KEY(SID) REFERENCES student(SID);
ALTER TABLE SCORE ADD FOREIGN KEY(CID) REFERENCES COURSE(CID);

INSERT INTO student VALUES(1, '小龙女', 18, '女'), (2, '阿紫', 19, '女'), (3, '虚竹', 20, '男');

INSERT INTO COURSE VALUES(1, '语文'), (2, '数学'), (3, '英语');

INSERT INTO SCORE VALUES(1, 1, 78), (1, 2, 75), (2, 1, 88), (2, 3, 90), (3, 2, 80), (3, 3, 65);

USE MYDB3;
-- 多表查询
CREATE TABLE DEPT1(
	DEPTNO VARCHAR(20) PRIMARY KEY,
	NAME VARCHAR(20)
);

CREATE TABLE EMP1(
	EID VARCHAR(20) PRIMARY KEY,
	ENAME VARCHAR(20),
	AGE INT,
	DEPT_ID VARCHAR(20)
);

INSERT INTO DEPT1 VALUES('1001', '研发部');
INSERT INTO DEPT1 VALUES('1002', '销售部');
INSERT INTO DEPT1 VALUES('1003', '财务部');
INSERT INTO DEPT1 VALUES('1004', '人事部');

INSERT INTO EMP1 VALUES('1', '乔峰', 20, '1001');
INSERT INTO EMP1 VALUES('2', '段誉', 21, '1001');
INSERT INTO EMP1 VALUES('3', '虚竹', 23, '1001');
INSERT INTO EMP1 VALUES('4', '阿紫', 18, '1001');
INSERT INTO EMP1 VALUES('5', '扫地僧', 85, '1002');
INSERT INTO EMP1 VALUES('6', '李秋水', 33, '1002');
INSERT INTO EMP1 VALUES('7', '鸠摩智', 50, '1002');
INSERT INTO EMP1 VALUES('8', '天山童姥', 60, '1003');
INSERT INTO EMP1 VALUES('9', '慕容博', 58, '1003');
INSERT INTO EMP1 VALUES('10', '丁春秋', 71, '1005');

-- 交叉连接查询
-- 返回被连接的两个表的所有数据行的笛卡尔积
-- 笛卡尔积是一张表的每一行去和另一张表的任意一行进行匹配
-- 假如A有M行数据，B有N行，则返回M*N行数据
-- 笛卡尔积会返回许多冗余数据
SELECT * FROM DEPT1, EMP1;
SELECT * FROM DEPT1, EMP1 WHERE DEPT1.DEPTNO = EMP1.DEPT_ID;
-- 内连接查询，求表的共同部分
-- 隐式连接: SELECT * FROM A, B WHERE 条件
-- 显示连接: SELECT * FROM A INNER JOIN B ON 条件 (INNER可省略)
SELECT * FROM DEPT1 JOIN EMP1 ON DEPTNO = DEPT_ID;
SELECT * FROM DEPT1 JOIN EMP1 ON DEPTNO = DEPT_ID AND NAME = '研发部';
SELECT * FROM DEPT1 JOIN EMP1 ON DEPTNO = DEPT_ID AND NAME IN('研发部', '销售部');
SELECT NAME, COUNT(1) FROM DEPT1 JOIN EMP1 ON DEPTNO = DEPT_ID GROUP BY NAME;
SELECT NAME, COUNT(1) PEOPLE FROM DEPT1 JOIN EMP1 ON DEPTNO = DEPT_ID GROUP BY NAME HAVING PEOPLE >= 3 ORDER BY PEOPLE DESC;
-- 外连接查询
-- 左外连接，右外连接，满外连接（注：MYSQL中对FULL JOIN 支持不好，可以用UNION代替）
-- SELECT * FROM A LEFT OUTER JOIN B ON 条件 (以下包括此OUTER都可以省略) A表全部保留,B表相应部分保留,其余为NULL
-- SELECT * FROM A LEFT JOIN B ON 条件1 LEFT JOIN C ON 条件2……
-- SELECT * FROM A RIGHT OUTER JOIN B ON 条件
-- SELECT * FROM A FULL OUTER JOIN B ON 条件
SELECT * FROM DEPT1 A LEFT JOIN EMP1 B ON A.DEPTNO = B.DEPT_ID;
SELECT * FROM DEPT1 RIGHT JOIN EMP1 ON DEPTNO = DEPT_ID;

SELECT * FROM DEPT1 RIGHT JOIN EMP1 ON DEPTNO = DEPT_ID; -- 不能执行
SELECT * FROM DEPT1 A LEFT JOIN EMP1 B ON A.DEPTNO = B.DEPT_ID
UNION
SELECT * FROM DEPT1 RIGHT JOIN EMP1 ON DEPTNO = DEPT_ID; -- UNION ALL 拼接不去重, UNION 拼接去重

子查询：SELECT嵌套的查询
USE mydb3;
-- 单行单列
SELECT * FROM emp1 WHERE AGE = (SELECT MAX(AGE) FROM EMP1);
-- 多行单列
SELECT * FROM emp1 WHERE DEPT_ID IN(SELECT DEPTNO FROM dept1 WHERE NAME IN('研发部', '销售部'));
-- 多行多列
SELECT * FROM (SELECT * FROM dept1 WHERE NAME = '研发部') A JOIN (SELECT * FROM emp1 WHERE AGE < 30) B ON A.DEPTNO = B.DEPT_ID;
SELECT * FROM EMP1 WHERE AGE < 30 AND DEPT_ID IN(SELECT DEPTNO FROM dept1 WHERE NAME = '研发部');
-- ALL
SELECT * FROM emp1 WHERE AGE > ALL(SELECT AGE FROM EMP1 WHERE DEPT_ID = '1003');
SELECT * FROM EMP1 WHERE DEPT_ID != ALL(SELECT DEPTNO FROM dept1);
-- ANY 和 SOME 一样
SELECT * FROM emp1 WHERE AGE > ANY(SELECT AGE FROM emp1 WHERE DEPT_ID = '1003') AND DEPT_ID != '1003';
SELECT * FROM emp1 WHERE AGE > SOME(SELECT AGE FROM emp1 WHERE DEPT_ID = '1003') AND DEPT_ID != '1003';
-- IN
SELECT EID, ENAME FROM emp1 WHERE DEPT_ID IN(SELECT DEPTNO FROM dept1 WHERE NAME IN('研发部', '销售部'));
-- EXISTS 不会返回任何数据只是判断真假
-- 数据量大的时候推荐使用EXISTS
SELECT * FROM emp1 A WHERE EXISTS(SELECT * FROM emp1 WHERE A.AGE > 60);
SELECT * FROM emp1 A WHERE EXISTS(SELECT * FROM dept1 B WHERE A.DEPT_ID = B.DEPTNO);

自关联查询：一张表当多张表使用
USE mydb3;
CREATE TABLE T_SANGUO(
	EID INT PRIMARY KEY,
	ENAME VARCHAR(20),
	MANAGER_ID INT,
	FOREIGN KEY(MANAGER_ID) REFERENCES T_SANGUO(EID) -- 添加自关联约束
);
INSERT INTO T_SANGUO VALUES(1, '刘协', NULL);
INSERT INTO T_SANGUO VALUES(2, '刘备', 1);
INSERT INTO T_SANGUO VALUES(3, '关羽', 2);
INSERT INTO T_SANGUO VALUES(4, '张飞', 2);
INSERT INTO T_SANGUO VALUES(5, '曹操', 1);
INSERT INTO T_SANGUO VALUES(6, '许诸', 5);
INSERT INTO T_SANGUO VALUES(7, '典韦', 5);
INSERT INTO T_SANGUO VALUES(8, '孙权', 1);
INSERT INTO T_SANGUO VALUES(9, '周瑜', 8);
INSERT INTO T_SANGUO VALUES(10, '鲁肃', 8);

SELECT A.ENAME NAME, B.ENAME MANAGER_NAME FROM T_SANGUO A LEFT JOIN T_SANGUO B ON A.MANAGER_ID = B.EID;
SELECT A.ENAME NAME, B.ENAME MANAGER_NAME, C.ENAME FROM T_SANGUO A LEFT JOIN T_SANGUO B ON A.MANAGER_ID = B.EID LEFT JOIN T_SANGUO C ON B.MANAGER_ID = C.EID;

日期变量可以直接比较

函数：封装好的模板代码
聚合函数：GROUP_CONCAT()，实现行的合并
CREATE DATABASE MYDB1;
USE MYDB1;
CREATE TABLE EMP(
	EMP_ID INT PRIMARY KEY AUTO_INCREMENT COMMENT '编号',
	EMP_NAME CHAR(20) NOT NULL DEFAULT '' COMMENT '姓名',
	SALARY DECIMAL(10, 2) NOT NULL DEFAULT 0 COMMENT '工资',
	DEPARTMENT CHAR(20) NOT NULL DEFAULT '' COMMENT '部门'
);

INSERT INTO EMP(EMP_NAME, SALARY, DEPARTMENT)
VALUES('张晶晶', 5000, '财务部'), ('王飞飞', 5800, '财务部'), ('赵刚', 6200, '财务部'), ('刘小贝', 5700, '人事部'),
('王大鹏', 6700, '人事部'), ('张小斐', 5200, '人事部'), ('刘云云', 7500, '销售部'), ('刘云鹏', 7200, '销售部'),
('刘云鹏', 7800, '销售部');

SELECT GROUP_CONCAT(EMP_NAME) FROM EMP;
SELECT GROUP_CONCAT(EMP_NAME SEPARATOR ';') FROM EMP;

SELECT DEPARTMENT, GROUP_CONCAT(EMP_NAME) FROM EMP GROUP BY DEPARTMENT;
SELECT DEPARTMENT, GROUP_CONCAT(EMP_NAME ORDER BY SALARY DESC SEPARATOR ';') FROM EMP GROUP BY DEPARTMENT;

数学函数
USE MYDB2;
SELECT CATEGORY_ID, ROUND(AVG(PRICE), 2) FROM PRODUCT GROUP BY CATEGORY_ID; -- 四舍五入
SELECT CATEGORY_ID, TRUNCATE(AVG(PRICE), 2) FROM PRODUCT GROUP BY CATEGORY_ID; -- 直接截取

字符串函数
SELECT CHAR_LENGTH('HELLO');
SELECT CHAR_LENGTH('你好啊'); -- 返回字符数

SELECT LENGTH('HELLO');
SELECT LENGTH('你好啊'); -- 返回字节

SELECT CONCAT('HELLO',' ','WORLD');
SELECT CONCAT_WS(' ','HELLO','WORLD');

SELECT FIELD('AA','BBB','AA','CC'); -- 返回字符串在列表中第一次出现的位置，从1开始，如果没有返回0

SELECT LTRIM('  HELLO') -- 去掉字符串左边的空格
SELECT RTRIM('HELLO   ') -- 去掉字符串右边的空格
SELECT TRIM('  HELLO  ') -- 去除两端空格

-- 从位置N开始截取M个字符，同SUBSTRING(S,N,M)
SELECT MID('HELLO WORLD', 2, 3); -- 从0开始

SELECT POSITION('AA' IN 'AABBBBCCAA');

SELECT REPLACE('AABBAACC','AA','BB');

SELECT REVERSE('HELLO');

SELECT RIGHT('HELLO',3); -- 返回后几个字符

SELECT STRCMP('HELLO','WORLD'); -- 1表示STR1比STR2出现的早，同理可得其他

SELECT SUBSTR('HELLO', 2, 3);
SELECT SUBSTRING('HELLO', 2, 3);

SELECT UCASE('hello');
SELECT UPPER('hello');

SELECT LCASE('HELLO');
SELECT LOWER('HELLO');

日期函数
SELECT UNIX_TIMESTAMP(); -- 获取时间戳（毫秒值）
SELECT UNIX_TIMESTAMP('2022-01-17 08:08:08'); -- 将指定日期字符串转为毫秒值

SELECT FROM_UNIXTIME(1642378088, '%Y-%M-%d %H:%i:%s'); -- 将指定毫秒值转为日期

SELECT CURDATE();
SELECT CURRENT_DATE(); -- 获取当前的年月日

SELECT CURRENT_TIME();
SELECT CURTIME(); -- 获取当前的时分秒

SELECT CURRENT_TIMESTAMP(); -- 获取当前年月日时分秒

SELECT DATE('2022-12-12 12:34:56'); -- 从日期中获取年月日

SELECT DATEDIFF('2021-12-23', '2008-08-08'); -- 计算两日期间的天数

SELECT TIMEDIFF('12:12:12','10:18:56'); -- 计算两时间间的差值

SELECT DATE_FORMAT('2021-1-1 1:1:1','%Y-%m-%d %h:%i:%s'); -- 日期格式化

SELECT STR_TO_DATE('2021-1-1 1:1:1','%Y-%m-%d %h:%i:%s'); -- 将字符串转为日期
SELECT STR_TO_DATE('August 10 2017','%M %d %Y');

SELECT DATE_SUB('2021-10-01', INTERVAL 2 DAY); -- 将日期进行减法
SELECT DATE_ADD('2021-10-01', INTERVAL 2 DAY); -- 将日期进行加法
SELECT DATE_ADD('2021-10-01', INTERVAL 2 MONTH);

SELECT EXTRACT(YEAR FROM '2021-12-13 11:12:13'); -- 从日期中获取年
SELECT EXTRACT(MONTH FROM '2021-12-13 11:12:13');
SELECT EXTRACT(DAY FROM '2021-12-13 11:12:13');

SELECT LAST_DAY('2021-08-13'); -- 获取指定日期所在月的最后一天

SELECT MAKEDATE('2021',53); -- 获取指定年的日期

SELECT YEAR('2021-12-13 11:12:13');
SELECT QUARTER('2021-12-13 11:12:13'); -- 获取季度

控制流函数
case expression
when condition1 then result1
when condition2 then result2
else result
end

USE mydb2;
-- 方法一
SELECT
	*,
	CASE payType
		WHEN 1 THEN '微信支付'
		WHEN 2 THEN '支付宝支付'
		WHEN 3 THEN '银行卡支付'
		ELSE '其他支付方式'
	END AS payTypeStr
FROM orders;

-- 方法二
SELECT
	*,
	CASE
		WHEN payType=1 THEN '微信支付'
		WHEN payType=2 THEN '支付宝支付'
		WHEN payType=3 THEN '银行卡支付'
		ELSE '其他支付方式'
	END AS payTypeStr
FROM orders;

窗口函数
USE mydb2;
CREATE TABLE employee(
	dname VARCHAR(20),
	eid VARCHAR(20),
	ename VARCHAR(20),
	hiredate date,
	salary DOUBLE
);

INSERT INTO employee VALUES('研发部','1001','刘备','2021-11-01',3000);
INSERT INTO employee VALUES('研发部','1002','关羽','2021-11-02',5000);
INSERT INTO employee VALUES('研发部','1003','张飞','2021-11-03',7000);
INSERT INTO employee VALUES('研发部','1004','赵云','2021-11-04',7000);
INSERT INTO employee VALUES('研发部','1005','马超','2021-11-05',4000);
INSERT INTO employee VALUES('研发部','1006','黄忠','2021-11-06',4000);

INSERT INTO employee VALUES('销售部','1007','曹操','2021-11-01',2000);
INSERT INTO employee VALUES('销售部','1008','许诸','2021-11-02',3000);
INSERT INTO employee VALUES('销售部','1009','典韦','2021-11-03',5000);
INSERT INTO employee VALUES('销售部','1010','张辽','2021-11-04',6000);
INSERT INTO employee VALUES('销售部','1011','徐晃','2021-11-05',9000);
INSERT INTO employee VALUES('销售部','1012','曹洪','2021-11-06',6000);

SELECT
	dname,
	ename,
	salary,
	ROW_NUMBER() over ( PARTITION BY dname ORDER BY salary DESC ) AS rn1,
	RANK() over ( PARTITION BY dname ORDER BY salary DESC ) AS rn2,
	DENSE_RANK() over ( PARTITION BY dname ORDER BY salary DESC ) AS rn3
FROM
	employee;
-- 去掉partition by 就全局排序
SELECT *
from (
SELECT
	dname,
	ename,
	salary,
	DENSE_RANK() over ( PARTITION BY dname ORDER BY salary DESC ) AS rn
FROM
	employee
) t
WHERE t.rn <= 3;
